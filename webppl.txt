var read_grammar = function(rule){
  return rule.split('->').join(',').split(' ').join(',').split(',').join('').split('')
}

read_grammar("A -> B C D a")

var grammar1 = 

var theta = sample(Beta({a: 0.1, b: 0.1}));
var grammar2 = {'rules': {'S': {rhs: [['X', 'a'], ['b', 'Y']], probs: [theta, 1 - theta]},
               'Y': {rhs: [['a', 'Y'], ['b']], probs: [0.4, 0.6]},
               'X': {rhs: [['X', 'b'], ['a']], probs: [0.2, 0.8]}}, 'probs': [0.3]};

var split_input_string = function(token){
  return token.split('')
}


////////////////////////////////////////////////////////////////////////////////


var pcfgTransition = function(symbol) {
  var rules = {'S': {rhs: [['T1', 'S', 'T2'], ['T1', 'S', 'T2'], ['T1'], ['T2']], probs: [0.5, 0.2, 0.1, 0.2]} }
  return rules[symbol].rhs[ discrete(rules[symbol].probs) ]
}

var preTerminal = function(symbol) {
  return symbol == 'T1' | symbol=='T2'
}

var terminal = function(symbol) {
  var rules = {'T1': {words: ['a'], probs: [1.0]},
               'T2': {words: ['b'], probs: [1.0]}}
  return rules[symbol].words[ discrete(rules[symbol].probs) ]
}


var pcfg = function(symbol) {
  preTerminal(symbol) ? [terminal(symbol)] : expand(pcfgTransition(symbol))
}

var expand = function(symbols) {
  if(symbols.length==0) {
    return []
  } else {
    var f = pcfg(symbols[0])
    return f.concat(expand(symbols.slice(1)))
  }
}

var model = function(){
  var y = pcfg("S")
  factor(_.isEqual(y.slice(0,3), ["a", "b", "a"]) ? 0 : -Infinity) // yield starts with "tall John"
  return y[3] ? y[3] : "" // distribution on next word?
}

viz.table(Infer({ model, method: 'enumerate', maxExecutions: 20}))

///////////////////////////////////////////////////////////////////////////////////